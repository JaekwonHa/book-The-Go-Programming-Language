# 9장 공유 변수를 이용한 동시성

8장에서 고루틴과 채널을 통해 동시성 프로그래밍을 어떻게 작성할 수 있는지 여러가지 패턴들을 살펴보았습니다.

9장에서는 여러 고루틴에서 변수를 공유할 때의 문제와 이러한 문제를 인지하고 해결할 수 있는 방법들을 알아봅니다.

마지막에는 고루틴과 운영체제 스레드 간의 기술적 차이점을 설명합니다.

### 9.1 경쟁 상태

동시성이라는 개념에 대해서 다시 생각해봅니다.

하나의 고루틴 속에서는 프로그램은 순차적으로 진행됩니다.

두개 이상의 고루틴이 실행 중일때, A 고루틴 내부의 x 이벤트와 B 고루틴 내부의 y 이벤트 중 어떤 것이 먼저 실행될지 확실할 수 없을 때 이벤트 x, y는 동시(concurrent)에 일어난다고 합니다.

또한 하나의 함수를 두개 이상의 고루틴에서 동기화 과정없이 동시에 호출해도 제대로 동작한다면 동시성에 안전(concurrent-safe)하다고 합니다.

특정 타입의 모든 접근 가능한 메소드와 연산이 동시성에 안전할 때 해당 타입이 동시성에 안전하다고 합니다.

이런 동시성에 안전하게 하기 위해서는 변수 scope을 단일 고루틴으로 제한하거나, 상호 배제 불변성을 통해 구현할 수 있습니다.

함수를 동시에 호출할 수 없는 이유는 교착 상태(dead lock), 자원 고갈, 경쟁 상태(race condition)등이 있고, 여기서는 경쟁 상태에 자세히 보겠습니다.

#### 예제. 공동 은행 계좌

엘리스와 밥이 공동 은행 계좌에 예금하고 잔고를 확인하는 상황을 생각해봅시다.

```go
var balance int

func Deposit(amount int) {
    balance = balance + amount
}

func Balance() int {
    b := balance
    return b
}
```
예금하고, 잔고 확인하는 2가지 함수가 있습니다.

엘리스가 200달러를 예금(A1)하고, 잔고를 확인(A2)하고, 밥이 100달러를 예금(B)합니다.

A1, A2, B 순서가 어떻게 되든 최종 잔액은 300달러입니다.

하지만 동시성 프로그래밍에서는 앨리스가 예금하는 사이인 잔고를 읽고(balance + amount) 갱신하기 전(balance = ...)에 밥이 예금해서 밥의 거래내역이 사라질 수 있습니다.

왜냐하면 입금 작업이라는게 실제로는 읽기와 쓰기 두 동작의 연속이기 때문입니다. (간섭 현상이 발생할 수 있음)

이러한 문제는 데이터에 대한 접근이 갱신을 일으킬때 발생할 수 있고, 특히나 단일 변수보다 큰 인터페이스, 문자열, 슬라이스 등의 변수가 포함되면 상황이 더 심각해집니다.

#### 데이터 갱신을 회피하는 방법 3가지

> 데이터 경쟁이란 두 고루틴이 같은 변수에 동시에 접근하고, 최소 1개의 접근에서 변수를 갱신할 때 일어납니다

1. 변수를 갱신하지 않는다.

2. 여러 고루틴에서의 변수 접근을 피하는 것이다. 변수를 단일 고루틴에 국한시킨다.

변수를 조회하거나 갱신하려면 변수를 가지고 있는 고루틴에게 채널로 요청합니다.

채널 요청으로 제한된 변수로의 접근을 중개하는 고루틴을 해당 변수의 *관리 고루틴*이라 합니다.

> Go 슬로건: 메모리 공유로 통신하지 말라. 대신 통신으로 메모리를 공유하라.

3. 여러 고루틴의 변수 접근을 허용하지만 한번에 하나씩만 접근한다. (상호배제)

### 9.2 상호 배제: sync.Mutex

8.6절에서 사용한 카운팅 세마포어를 사용할 수 있습니다. (용량이 1인 채널을 사용. 이진 세마포어)

이런 방식은 sync 패키지의 Mutex 타입에서 직접 지원되므로 유용합니다. (Lock, Unlock 함수를 사용)

특정 변수에 접근할 때마다 토큰을 획득하고, 완료 후에 토큰을 반납하는 과정이 있습니다.

#### 예제. Withdraw

```go
func Withdraw(amount int) bool {
    Deposit(-amount)
    if Balance() < 0 {
        Deposit(amount)
        return false
    }
    return true
}
```
해당 함수를 과도하게 호출하면 잔고가 일시적으로 0 이하로 떨어질 수 있습니다.

이를 방지하기 위해 아래와 같이 뮤텍스 잠금을 이용해볼 수 있습니다.

```go
func Withdraw(amount int) bool {
    mu.Lock()
    defer mn.Unlock()
    Deposit(-amount)
    if Balance() < 0 {
        Deposit(amount)
        return false
    }
    return true
}
```
하지만 이런 방식은 Deposit() 함수 내부에서 다시 잔고를 변경하기 전에 뮤텍스를 얻는 행위때문에 동작하지 않습니다.

뮤텍스 잠금은 Withdraw 함수에서 이미 Lock 되었기에 Deposit 함수에서 다시 Lock 하게되면 데드락이 발생합니다.

Go의 뮤텍스는 재진입을 허용하고 있지 않은데, 이 이유는 재진입 뮤텍스는 다른 고루틴에서 공유 변수에 접근하지 못하게할 수는 있지만, 다시 불변 속성을 부여하는 것까지 보장할 수는 없습니다.

책에서는 위와 같이 설명하고 있지만, 단순히 생각해봤을때 뮤텍스가 재진입하게 되면 공유 변수에 접근하고 있는 고루틴이 2개가 될 수 있다는 말이고, 한쪽 고루틴에서 먼저 Unlock하게 되면 의도하지 않은 제 3의 고루틴에서 다시 락을 획득해버릴 수도 있을 것 있습니다..

이런 문제를 해결하기 위한 가장 일반적인 방법은 Deposit 함수를 두개로 분할하는 것입니다. (Deposit, deposit)

익스포트되지 않은 함수는 잠금 획득 상태에서만 호출한다고 가정합니다.

### 9.3 읽기/쓰기 뮤텍스: sync.RWMutex

읽기 작업만 하는 경우 공유 자원에 병렬로 접근하여도 문제가 없다. 하지만 쓰기 작업을 하게 될 경우 반드시 배타적으로 접근해야 한다.

`sync.RWMutex`를 사용하면 다중 읽기, 단일 쓰기 잠금을 구현할 수 있다.

* RLock(), RUnlock()
* Lock(), Unlock()

다만 경합(race condition)이 있는 상태에서만 RWMutex가 장점을 가지고, 내부적으로는 Mutex보다 복잡하기 때문에 경합이 없는 잠금에서는 일반 뮤텍스보다 느리다.

### 9.4 메모리 동기화

Balance 메소드에는 상호 배제가 왜 필요한지 궁금해 할 수 있습니다.

단일 작업으로 이뤄져있기 때문에 다른 고루틴이 '중간에' 실행되어도 아무런 위험이 없는 것 처럼 보입니다.

뮤텍스가 필요한 2가지 이유가 있습니다.

1. Balance가 Withdraw 같은 다른 작업 도중에 실행되지 않게 하는 것은 그 반대와 마찬가지로 중요합니다.
2. 동기화가 영향을 끼치는 것은 여러 고루틴의 실행 순서를 제어하는 것 이상입니다. 동기화는 메모리에도 영향을 미칩니다.

```go
var x, y int
go func() {
    x = 1
    fmt.Print("y: ", y, " ")
}
go func() {
    y = 1
    fmt.Print("x: ", x, " ")
}
```
위와 같은 로직을 생각해봅시다.

아래와 같은 결과를 생각해볼 수 있습니다.

* y: 0, x: 1
* x: 0, y: 1
* x: 1, y: 1
* y: 1, x: 1

하지만 아래의 결과도 가능합니다. 어떻게 설명할 수 있을까요?

* x: 0, y: 0
* y: 0, x: 0

현대의 CPU는 각 코어가 각자의 지역 캐시를 가지고 있습니다. L1, L2, L3

![cpu_cache_1](https://github.com/JaekwonHa/book-The-Go-Programming-Language/blob/master/book-contents/assets/cpu_cache.png?raw=true)

![cpu_cache_2](https://github.com/JaekwonHa/book-The-Go-Programming-Language/blob/master/book-contents/assets/cpu_cache2.jpg?raw=true)

변수가 할당(x / y)하는 것과 출력 (y / x)가 각각 다른 변수를 참조하고 있으므로 CPU는 두 구문의 순서가 실행 결과에 영향을 미칠 수 없다고 판단하여 둘을 교환할 수 있습니다.

또한 두 고루틴이 서로 다른 CPU에서 실행된다면 각자 캐시를 가지게 되고, 한 고루틴에서의 쓰기 결과가 메인 메모리로 동기화되기 전에는 다른 고루틴에서는 그 쓰기 결과를 알 수가 없기에 이전 값을 출력하게 됩니다.

따라서 메모리를 통해 동기화가 이뤄져야 각 고루틴에서 예상되는 실행 결과를 얻을 수 있습니다.

### 9.5 게으른 초기화: sync.Once

고비용이 드는 초기화 단계는 필요한 순간까지 늦추면 좋습니다. 필요여부와 상관없이 무조건 초기화하는 것은 프로그램 시작 시간을 늦추고, 불필요한 작업이 될 수 있습니다.

```go
func loadIcons() {
    icons = map[string]image.Image{
        "spades.png": loadIcon("spades.png")
}
// NOTE: 동기화에 안전하지 않음!
func Icon(name string) image.Image {
    if icons == nil {
        loadIcons() // 1번만 초기화됨
    }
}
```
필요한 순간에 1번만 초기화를 하기 위해서 위와 같은 코드를 작성할 수 있습니다.

하지만 명시적인 동기화가 없기 때문에 여러개의 고루틴이 수행시에는 여러번 초기화될 수 있습니다.

icons로의 접근을 상호 배타적으로 강제하는 3가지 방법이 있습니다.

#### Lock / Unlock 활용

```go
func Icon(name string) image.Image {
    mn.Lock()
    defer mn.Unlock()
    if icons == nil {
        loadIcons()
    }
    return icons[name]
}
```
쓰기 잠금을 통해서 상호 배타를 강제합니다.

하지만 초기화 이후에도 항상 Lock을 획득하고 반납하기 때문에 경합이 일어날 수 있습니다.

#### RLock / RUnlock 활용

```go
var mu sync.RWMutex
var icons map[string]image.Image

func Icon(name string) image.Image {
    mn.RLock()
    if icons != nil {
        icon := icons[name]
        mn.RUlock()
        return icon
    }
    mn.RUlock()

    mn.Lock()
    if icons == nil {
        loadIcons()
    }
    icon := icons[name]
    mn.UnLock()
    return icon
}
```
읽기 잠금을 획득하고 맵을 참조 후 nil이 아니면 읽기 잠금 반납 후 값을 반환합니다.

더 큰 동시성을 제공하긴 하지만 코드의 복잡도가 올라갈 수 있습니다.

#### sync.Once 활용

```go
var loadIconsOnce sync.Once
var icons map[string]image.Image

func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icon
}
```
sync.Once Do() 함수를 통해 코드를 훨씬 간결하게 작성할 수 있습니다.

### 9.6 경쟁 상태 검출

Go 런타임과 도구에는 정교하고 사용하기 쉬운 동적 분석 도구인 경쟁 상태 검출기가 있습니다.

go build, go run, go test 뒤에 -race 플래그를 추가하여 한 고루틴에서 최근에 다른 고루틴이 수정한 공유 변수를 중간의 동기화 과정 없이 읽거나 쓰는 경우를 감지합니다.

모든 데이터 경쟁을 출력하지만, 실행 시의 경쟁 상태를 감지만 할 수 있고 발생하지 못하게 하는건 아닙니다.

또한 더 많은 실행시간과 메모리가 필요하지만, 충분히 유용한 도구입니다.

### 9.7 예제: 동시 넌블로킹 캐시

이 에제에서는 실제 동시성 프로그램에서 자주 발생하는 문제를 해결하기 위한 추상화 계층. 동시 넌블로킹 캐시(Concurrent Non-Blocking Cache)를 만들 것입니다.

함수의 결과를 캐시해서 1번만 계산하게 하는 것인데, 동시성에 안전하고 전체 캐시에 대한 단일 잠금 설계로 경합 상태를 방지할 수 있습니다.

memo1 예제의 Get 함수는 동시성에 안전하지 않습니다. 두개 이상의 고루틴이 동일한 key를 가지고 호출 시에 각자 cache를 업데이트하기 위해 공유변수에 접근할 것입니다.

memo2 예제는 sync.Mutex를 사용해 cache에 접근하는 것이 상호 배타적으로 동작합니다.

하지만 모든 Get 함수 호출이 잠금을 획득하므로 벙렬화시킨 IO 작업이 다시 순차적으로 변경됩니다.

이런 결과를 피하기 위해서 cache된 호출은 잠금없이 진행될 수 있는 넌블로킹 캐시가 필요합니다.

memo3 예제는 임계 영역을 2개로 나누었습니다. 조회할때, 조회결과가 없을때 갱신할때.

성능은 향상되었지만, url을 2번 조회하게 되는 문제를 피할 수 없습니다.

중복 작업은 하지 않는 것이 좋고, 이런 기능을 중복 억제(duplicate suppression)이라 합니다.

memo4 예제에서는 브로드캐스트(8.9절)를 이용해서 시간이 오래 걸리는 작업의 '준비'상태를 기다리게 하고, 통과시킬 수 있습니다.

(예제 보면서 설명)

이로써 동시성, 중복 억제, 넌블로킹 캐시가 완료되었습니다.

앞선 구현은 뮤텍스를 사용했는데, 맵 변수를 관리 고루틴 (8.4.2절 파이프라인)에 국한시키고 Get 호출시에 메시지를 보내는 설계로 변경할 수 있습니다. memo5

(예제 보면서 설명)

memo4, memo5는 다수의 동시성 구조체를 복잡성 없이 만드는 두 가지 방법(공유변수와 잠금 or 순차 프로세스 통신)을 보여주었습니다.

요구사항에 따라서 어떤 것이 나을지 항상 명확하진 않겠지만, 어떻게 문제를 해결했는지 알아둘 가치는 있습니다.

접근법에 따라 코드는 더 간결해질 수 있습니다.

### 9.8 고루틴과 스레드

#### 9.8.1 가변 스택

> https://yaboong.github.io/java/2018/05/26/java-memory-management/

OS의 스레드는 고정 크기의 메모리 블록(2MB)의 스택 영역을 가집니다.

고루틴은 일반적으로 2KB의 작은 스택으로 시작하고, 스택의 크기가 필요한 만큼 늘어나고 줄어듭니다. (1GB가 될수도 있음)

#### 9.8.2 고루틴 스케줄링

OS 스레드는 OS 커널에 의해 스케쥴되는데, 매 밀리초마다 하드웨어 타이머가 프로세스를 인터셉트해 커널 함수 scheduler가 호출되게 됩니다.

컨텍스트 스위치가 발생하게 되며, 한 스레드에서 다른 스레드로 제어를 넘기려면 한 사용자 스레드의 상태를 메모리에 저장하고, 다른 스레드의 상태를 복원한 후 스케쥴러의 자료 구조를 갱신하게 됩니다.

> https://tech.ssut.me/goroutine-vs-threads/

Go 런타임은 n개의 OS 스레드에 있는 m개의 고루틴을 다중화하는 m:n 스케쥴링 기법을 사용합니다.

Go 스케쥴러는 역할은 커널 스케쥴러와 유사하지만 단일 Go 프로그램의 고루틴에 제한됩니다. 커널 컨텍스트 스위치가 일어나지 않으므로 고루틴의 스케쥴 재조정은 스레드 재조정보다 훨씬 비용이 적게 듭니다.

#### 9.8.3 GOMAXPROCS

GOMAXPROC라는 파라미터를 사용해 동시에 얼마나 많은 OS 스레드를 사용할지 결정합니다.

`GOMAXPROCS=1 go run hacker-cliche.go`

#### 9.8.4 고루틴에는 식별자가 없다.

멀티스레딩을 지원하는 대부분의 프로그래밍 언어에서는 스레드에 일반적인 값인 정수나 포인터로 얻을 수 있는 독자적 식별자가 있습니다.

이는 스레드 로컬을 사용하기 쉽게 만들어 줍니다.

스레드 로컬이란 말 그대로 스레드의 지역변수입니다. 하나의 스레드 내부에서는 언제나 읽고 쓸 수 있는 변수입니다.

예를 들면, Spring Security에서는 ContextHolder라는 스레드 로컬 변수를 사용하는데, 이는 어떤 함수에서든지 현재 요청을 처리 중인 스레드에 담긴 정보(사용자 인증 정보 등)를 쉽게 가져올 수 있는 메커니즘을 제공합니다.

고루틴에서는 개발자가 접근 가능한 고루틴의 식별자가 없는데, 이는 스레드 로컬의 남용을 막기 위해서 입니다.

전역변수에 과도하게 의존하는 프로그램과 마찬가지로 함수의 동작이 주어진 인자 외에 스레드에 저장된 스레드 로컬 변수에 의해서도 결과가 바뀔 수 있다는 원격 작용이라는 비정상 상태로 이어지게 됩니다.

Go는 함수의 동작에 영향을 주는 파라미터를 명확하게 하고, 단순한 방식으로 프로그래밍 하기를 권장합니다. (하지만 동시성 프로그래밍은 어렵다..)

이렇게 해야 읽기 쉬워지고, 주어진 함수의 하위 작업이 스레드 식별자를 신경쓰지 않고 여러 고루틴에 자유롭게 할당할 수 있는 이점이 있습니다.
