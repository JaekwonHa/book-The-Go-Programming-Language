# 9장 공유 변수를 이용한 동시성

8장에서 고루틴과 채널을 통해 동시성 프로그래밍을 어떻게 작성할 수 있는지 여러가지 패턴들을 살펴보았습니다.

9장에서는 여러 고루틴에서 변수를 공유할 때의 문제와 이러한 문제를 인지하고 해결할 수 있는 방법들을 알아봅니다.

마지막에는 고루틴과 운영체제 스레드 간의 기술적 차이점을 설명합니다.

> https://tech.ssut.me/goroutine-vs-threads/

### 9.1 경쟁 상태

동시성이라는 개념에 대해서 다시 생각해봅니다.

하나의 고루틴 속에서는 프로그램은 순차적으로 진행됩니다.

두개 이상의 고루틴이 실행 중일때, A 고루틴 내부의 x 이벤트와 B 고루틴 내부의 y 이벤트 중 어떤 것이 먼저 실행될지 확실할 수 없을 때 이벤트 x, y는 동시(concurrent)에 일어난다고 합니다.

또한 하나의 함수를 두개 이상의 고루틴에서 동기화 과정없이 동시에 호출해도 제대로 동작한다면 동시성에 안전(concurrent-safe)하다고 합니다.

특정 타입의 모든 접근 가능한 메소드와 연산이 동시성에 안전할 때 해당 타입이 동시성에 안전하다고 합니다.

이런 동시성에 안전하게 하기 위해서는 변수 scope을 단일 고루틴으로 제한하거나, 상호 배제 불변성을 통해 구현할 수 있습니다.

함수를 동시에 호출할 수 없는 이유는 교착 상태(dead lock), 자원 고갈, 경쟁 상태(race condition)등이 있고, 여기서는 경쟁 상태에 자세히 보겠습니다.

#### 예제. 공동 은행 계좌

엘리스와 밥이 공동 은행 계좌에 예금하고 잔고를 확인하는 상황을 생각해봅시다.

엘리스가 200달러를 예금(A1)하고, 잔고를 확인(A2)하고, 밥이 100달러를 예금(B)합니다.

A1, A2, B 순서가 어떻게 되든 최종 잔액은 300달러입니다.

하지만 동시성 프로그래밍에서는 앨리스가 예금하는 사이인 잔고를 읽고(balance + amount) 갱신하기 전(balance = ...)에 밥이 예금해서 밥의 거래내역이 사라질 수 있습니다.

왜냐하면 입금 작업이라는게 실제로는 읽기와 쓰기 두 동작의 연속이기 때문입니다. (간섭 현상이 발생할 수 있음)

이러한 문제는 데이터에 대한 접근이 갱신을 일으킬때 발생할 수 있고, 특히나 단일 변수보다 큰 인터페이스, 문자열, 슬라이스 등의 변수가 포함되면 상황이 더 심각해집니다.

#### 데이터 갱신을 회피하는 방법 3가지

> 데이터 경쟁이란 두 고루틴이 같은 변수에 동시에 접근하고, 최소 1개의 접근에서 변수를 갱신할 때 일어납니다

1. 변수를 갱신하지 않는다.

2. 여러 고루틴에서의 변수 접근을 피하는 것이다. 변수를 단일 고루틴에 국한시킨다.

변수를 조회하거나 갱신하려면 변수를 가지고 있는 고루틴에게 채널로 요청합니다.

채널 요청으로 제한된 변수로의 접근을 중개하는 고루틴을 해당 변수의 *관리 고루틴*이라 합니다.

> Go 슬로건: 메모리 공유로 통신하지 말라. 대신 통신으로 메모리를 공유하라.

3. 여러 고루틴의 변수 접근을 허용하지만 한번에 하나씩만 접근한다. (상호배제)

### 9.2 상호 배제: sync.Mutex

8.6절에서 사용한 카운팅 세마포어를 사용할 수 있습니다. (용량이 1인 채널을 사용. 이진 세마포어)

이런 방식은 sync 패키지의 Mutex 타입에서 직접 지원되므로 유용합니다. (Lock, Unlock 함수를 사용)

특정 변수에 접근할 때마다 토큰을 획득하고, 완료 후에 토큰을 반납하는 과정이 있습니다.

#### 예제. Withdraw

```go
func Withdraw(amount int) bool {
    Deposit(-amount)
    if Balance() < 0 {
        Deposit(amount)
        return false
    }
    return true
}
```
해당 함수를 과도하게 호출하면 잔고가 일시적으로 0 이하로 떨어질 수 있습니다.

이를 방지하기 위해 아래와 같이 뮤텍스 잠금을 이용해볼 수 있습니다.

```go
func Withdraw(amount int) bool {
    mu.Lock()
    defer mn.Unlock()
    Deposit(-amount)
    if Balance() < 0 {
        Deposit(amount)
        return false
    }
    return true
}
```
하지만 이런 방식은 Deposit() 함수 내부에서 다시 잔고를 변경하기 전에 뮤텍스를 얻는 행위때문에 동작하지 않습니다.

뮤텍스 잠금은 Withdraw 함수에서 이미 Lock 되었기에 Deposit 함수에서 다시 Lock 하게되면 데드락이 발생합니다.

Go의 뮤텍스는 재진입을 허용하고 있지 않은데, 이 이유는 재진입 뮤텍스는 다른 고루틴에서 공유 변수에 접근하지 못하게할 수는 있지만, 다시 불변 속성을 부여하는 것까지 보장할 수는 없습니다.

책에서는 위와 같이 설명하고 있지만, 단순히 생각해봤을때 뮤텍스가 재진입하게 되면 공유 변수에 접근하고 있는 고루틴이 2개가 될 수 있다는 말이고, 한쪽 고루틴에서 먼저 Unlock하게 되면 의도하지 않은 제 3의 고루틴에서 다시 락을 획득해버릴 수도 있을 것 있습니다..

이런 문제를 해결하기 위한 가장 일반적인 방법은 Deposit 함수를 두개로 분할하는 것입니다. (Deposit, deposit)

익스포트되지 않은 함수는 잠금 획득 상태에서만 호출한다고 가정합니다.
